<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grafana Query IDE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            flex: 1;
        }

        header {
            background-color: #1a1a1a;
            border-bottom: 2px solid #333;
            padding: 20px 0;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 28px;
            color: #f46800;
            text-align: center;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .auth-section {
            background-color: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 14px;
            font-weight: 500;
        }

        input[type="text"],
        input[type="password"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 10px 12px;
            background-color: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input[type="text"]:focus,
        input[type="password"]:focus,
        input[type="number"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #f46800;
        }

        textarea {
            resize: vertical;
            min-height: 200px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            line-height: 1.5;
        }

        button {
            background-color: #f46800;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.3s ease;
            margin-right: 10px;
        }

        button:hover {
            background-color: #d65a00;
        }

        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .secondary-button {
            background-color: #333;
        }

        .secondary-button:hover {
            background-color: #444;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            min-width: 0; /* Prevents grid items from overflowing */
        }

        .query-section {
            background-color: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            min-width: 800px; /* Ensure minimum width for query section */
        }

        .history-section {
            background-color: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            max-height: 800px; /* Fixed maximum height */
        }

        #historyList {
            flex: 1;
            overflow-y: auto;
            max-height: 800px; /* Allow space for about 6 history items */
            margin-top: 10px;
        }

        /* Custom scrollbar for history list */
        #historyList::-webkit-scrollbar {
            width: 8px;
        }

        #historyList::-webkit-scrollbar-track {
            background: #0a0a0a;
            border-radius: 4px;
        }

        #historyList::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        #historyList::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .results-section {
            margin-top: 20px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            grid-column: 1 / -1;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .status.success {
            background-color: #1a3a1a;
            border: 1px solid #2a5a2a;
            color: #4ade80;
        }

        .status.error {
            background-color: #3a1a1a;
            border: 1px solid #5a2a2a;
            color: #f87171;
        }

        .table-wrapper {
            overflow-x: auto;
            margin-top: 15px;
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 4px;
        }

        .pagination-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding: 10px;
            background-color: #0a0a0a;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .pagination-info {
            color: #b0b0b0;
            font-size: 14px;
        }

        .pagination-buttons {
            display: flex;
            gap: 5px;
        }

        .pagination-buttons button {
            padding: 5px 10px;
            font-size: 12px;
            margin: 0;
        }

        .page-size-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #b0b0b0;
            font-size: 14px;
        }

        .series-selector {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #0a0a0a;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .series-selector label {
            display: block;
            margin-bottom: 8px;
            color: #f46800;
            font-weight: 500;
        }

        .series-dropdown {
            width: 100%;
            padding: 8px 12px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .series-info {
            margin-top: 8px;
            font-size: 12px;
            color: #888;
        }

        .series-stats {
            margin-top: 10px;
            padding: 10px;
            background-color: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .series-stats h4 {
            color: #f46800;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .stat-item {
            background-color: #0a0a0a;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            border: 1px solid #333;
        }

        .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 14px;
            color: #e0e0e0;
            font-weight: 500;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th {
            background-color: #2a2a2a;
            color: #f46800;
            padding: 10px;
            text-align: left;
            border: 1px solid #333;
            font-weight: 500;
        }

        td {
            padding: 8px 10px;
            border: 1px solid #333;
            color: #e0e0e0;
        }

        tr:hover {
            background-color: #252525;
        }

        .history-item {
            background-color: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .history-item:hover {
            border-color: #f46800;
        }

        .history-timestamp {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        .history-query {
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 12px;
            color: #b0b0b0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .history-datasource {
            font-size: 12px;
            color: #f46800;
            margin-top: 5px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 10px;
            border: 2px solid #f46800;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .auth-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #0a0a0a;
            border-radius: 4px;
        }

        .auth-status {
            font-size: 14px;
            color: #4ade80;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        pre {
            background-color: #0a0a0a;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.4;
            border: 1px solid #333;
        }

        .query-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .query-type-button {
            flex: 1;
            padding: 8px 16px;
            background-color: #2a2a2a;
            border: 1px solid #333;
            color: #b0b0b0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .query-type-button.active {
            background-color: #f46800;
            color: white;
            border-color: #f46800;
        }

        .section-title {
            font-size: 18px;
            margin-bottom: 15px;
            color: #f46800;
            font-weight: 400;
        }

        .time-range-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .advanced-options {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .view-toggle {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            justify-content: flex-end;
        }

        .view-toggle button {
            padding: 6px 12px;
            font-size: 12px;
            margin: 0;
            background-color: #333;
            border: 1px solid #555;
        }

        .view-toggle button.active {
            background-color: #f46800;
            border-color: #f46800;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin: 15px 0;
            background-color: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 15px;
        }

        .chart-wrapper {
            position: relative;
            height: 100%;
            width: 100%;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .chart-options {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .chart-option {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #b0b0b0;
        }

        .chart-option input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .chart-option select {
            padding: 4px 8px;
            font-size: 12px;
            min-width: 80px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .history-section {
                order: 2;
            }

            .time-range-section {
                grid-template-columns: 1fr;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .chart-controls {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .chart-options {
                justify-content: center;
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Grafana Query IDE</h1>
        </div>
    </header>

    <div class="container">
        <div class="auth-section">
            <h2 class="section-title">Authentication</h2>
            <div id="authInfo" class="auth-info hidden">
                <span class="auth-status">Connected to: <span id="connectedUrl"></span></span>
                <button class="secondary-button" onclick="disconnect()">Disconnect</button>
            </div>
            <div id="authForm">
                <div class="form-group">
                    <label for="grafanaUrl">Grafana URL</label>
                    <input type="text" id="grafanaUrl" placeholder="Enter your Grafana URL (e.g., https://grafana.example.com)">
                </div>
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="admin">
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" placeholder="password">
                </div>
                <button onclick="connect()">Connect</button>
            </div>
            <div id="authStatus"></div>
            <details style="margin-top: 15px;">
                <summary style="cursor: pointer; color: #888; font-size: 14px;">Connection Help</summary>
                <div style="margin-top: 10px; padding: 15px; background-color: #0a0a0a; border-radius: 4px; font-size: 13px; line-height: 1.6;">
                    <p style="margin-bottom: 10px;"><strong style="color: #f46800;">How to connect:</strong></p>
                    <ul style="margin-left: 20px; color: #b0b0b0;">
                        <li style="margin-bottom: 8px;">Enter your Grafana instance URL (e.g., https://grafana.example.com)</li>
                        <li style="margin-bottom: 8px;">Use your Grafana username and password</li>
                        <li style="margin-bottom: 8px;">The integrated proxy handles CORS automatically</li>
                    </ul>
                    <p style="margin-top: 10px;"><strong style="color: #f46800;">Troubleshooting:</strong></p>
                    <ul style="margin-left: 20px; color: #b0b0b0;">
                        <li style="margin-bottom: 8px;">401 Error: Check your username/password</li>
                        <li style="margin-bottom: 8px;">404 Error: Verify the Grafana URL is correct</li>
                        <li style="margin-bottom: 8px;">SSL Error: The proxy accepts self-signed certificates</li>
                    </ul>
                </div>
            </details>
        </div>

        <div class="main-content">
            <div class="query-section">
                <h2 class="section-title">Query Editor</h2>
                <div class="form-group">
                    <label for="datasource">Data Source</label>
                    <select id="datasource" disabled>
                        <option value="">Connect to Grafana first</option>
                    </select>
                </div>
                <div class="query-type-selector">
                    <button class="query-type-button active" onclick="setQueryType('influxql')">InfluxQL</button>
                    <button class="query-type-button" onclick="setQueryType('promql')">PromQL</button>
                </div>
                
                <div class="time-range-section">
                    <div class="form-group">
                        <label for="timeFrom">From (hours ago)</label>
                        <input type="number" id="timeFrom" value="1" min="0" step="0.1">
                    </div>
                    <div class="form-group">
                        <label for="timeTo">To (hours ago)</label>
                        <input type="number" id="timeTo" value="0" min="0" step="0.1">
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="query">Query</label>
                    <textarea id="query" placeholder="Enter your query here..." disabled></textarea>
                </div>
                
                <div class="advanced-options">
                    <h3 style="color: #f46800; margin-bottom: 10px; font-size: 16px;">Advanced Options</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="maxDataPoints">Max Data Points</label>
                            <input type="number" id="maxDataPoints" value="1000" min="1">
                        </div>
                        <div class="form-group">
                            <label for="intervalMs">Interval (ms)</label>
                            <input type="number" id="intervalMs" value="15000" min="1000" step="1000">
                        </div>
                    </div>
                    <div class="form-group" id="promqlOptions" style="display: none;">
                        <label>
                            <input type="checkbox" id="instantQuery" style="width: auto; margin-right: 8px;">
                            Instant Query (single point in time)
                        </label>
                    </div>
                </div>
                
                <div class="button-group">
                    <button id="executeBtn" onclick="executeQuery()" disabled>Execute Query</button>
                    <button class="secondary-button" onclick="clearQuery()">Clear</button>
                </div>
            </div>

            <div class="history-section">
                <h2 class="section-title">Query History</h2>
                <button class="secondary-button" onclick="clearHistory()" style="margin-bottom: 15px;">Clear History</button>
                <div id="historyList"></div>
            </div>

            <div class="results-section">
                <h2 class="section-title">Results</h2>
                <div id="results">
                    <p style="color: #888; text-align: center;">No query executed yet</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let grafanaConfig = {
            url: '',
            username: '',
            password: '',
            authHeader: ''
        };
        let currentQueryType = 'influxql';
        let datasources = [];
        let currentResults = null;
        let currentPage = 1;
        let pageSize = 100;
        let totalRows = 0;
        let selectedSeries = 0; // Track selected series for grouped results
        let currentViewMode = 'table'; // 'table' or 'chart'
        let chartInstance = null; // Store chart instance for cleanup

        // Initialize the app
        window.onload = function() {
            loadHistory();
            // Check if we have saved credentials
            const savedConfig = localStorage.getItem('grafanaConfig');
            if (savedConfig) {
                const config = JSON.parse(savedConfig);
                document.getElementById('grafanaUrl').value = config.url;
                document.getElementById('username').value = config.username;
                // Note: We don't save passwords for security
            }
            
            // Ensure the UI starts in disconnected state
            ensureDisconnectedState();
            
            // Check if we're running from the Docker container
            checkIfRunningInContainer();
        };

        // Ensure UI is in proper disconnected state
        function ensureDisconnectedState() {
            document.getElementById('authForm').classList.remove('hidden');
            document.getElementById('authInfo').classList.add('hidden');
            document.getElementById('datasource').innerHTML = '<option value="">Connect to Grafana first</option>';
            document.getElementById('datasource').disabled = true;
            document.getElementById('query').disabled = true;
            document.getElementById('executeBtn').disabled = true;
            document.getElementById('authStatus').innerHTML = '';
        }

        // Check if running in container and show appropriate message
        async function checkIfRunningInContainer() {
            try {
                const response = await fetch('/health');
                if (response.ok) {
                    const urlField = document.getElementById('grafanaUrl');
                    urlField.placeholder = 'Enter your Grafana URL (e.g., https://grafana.example.com)';
                    // Show a tip about using the integrated proxy
                    const tip = document.createElement('div');
                    tip.style.cssText = 'margin-top: 5px; font-size: 12px; color: #4ade80;';
                    tip.textContent = '✓ Running with integrated proxy - CORS handling enabled';
                    urlField.parentNode.appendChild(tip);
                }
            } catch (e) {
                // Not running in container, ignore
            }
        }

        // Make API request with proper headers
        async function makeApiRequest(endpoint, options = {}) {
            // If we're running from the same origin, we're using the integrated proxy
            const isIntegratedProxy = window.location.pathname !== '/grafana-query-ide.html';
            
            if (isIntegratedProxy) {
                // Use the proxy endpoint
                const headers = {
                    'Authorization': grafanaConfig.authHeader,
                    'X-Grafana-URL': grafanaConfig.url,
                    'Accept': 'application/json',
                    ...options.headers
                };

                return fetch(`/api${endpoint.replace('/api', '')}`, {
                    ...options,
                    headers
                });
            } else {
                // Direct connection (will likely fail due to CORS)
                return fetch(`${grafanaConfig.url}${endpoint}`, {
                    ...options,
                    headers: {
                        'Authorization': grafanaConfig.authHeader,
                        'Accept': 'application/json',
                        ...options.headers
                    }
                });
            }
        }

        // Authentication functions
        async function connect() {
            const url = document.getElementById('grafanaUrl').value.trim();
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value.trim();

            if (!url || !username || !password) {
                showStatus('authStatus', 'Please provide URL, username, and password', 'error');
                return;
            }

            // Ensure URL doesn't end with slash
            grafanaConfig.url = url.replace(/\/$/, '');
            grafanaConfig.username = username;
            grafanaConfig.password = password;
            
            // Create Basic Auth header
            const credentials = btoa(`${username}:${password}`);
            grafanaConfig.authHeader = `Basic ${credentials}`;

            showStatus('authStatus', 'Connecting...', 'loading');

            try {
                // Test connection by fetching datasources
                const response = await makeApiRequest('/api/datasources');

                if (!response.ok) {
                    let errorMessage = `${response.status} ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.message) {
                            errorMessage = errorData.message;
                        } else if (errorData.error) {
                            errorMessage = errorData.error;
                        }
                    } catch (e) {
                        // If response is not JSON, try text
                        try {
                            const errorText = await response.text();
                            if (errorText) {
                                errorMessage = errorText;
                            }
                        } catch (e2) {
                            // Ignore
                        }
                    }
                    throw new Error(`Authentication failed: ${errorMessage}`);
                }

                datasources = await response.json();
                
                // Save config (without password)
                localStorage.setItem('grafanaConfig', JSON.stringify({
                    url: grafanaConfig.url,
                    username: grafanaConfig.username
                }));

                // Update UI
                showStatus('authStatus', 'Connected successfully!', 'success');
                document.getElementById('authForm').classList.add('hidden');
                document.getElementById('authInfo').classList.remove('hidden');
                document.getElementById('connectedUrl').textContent = `${grafanaConfig.url} (${username})`;
                
                populateDatasources();
                enableQueryEditor();

            } catch (error) {
                showStatus('authStatus', `Connection failed: ${error.message}`, 'error');
                console.error('Connection error:', error);
            }
        }

        function disconnect() {
            grafanaConfig = { 
                url: '', 
                username: '', 
                password: '', 
                authHeader: ''
            };
            datasources = [];
            currentResults = null;
            localStorage.removeItem('grafanaConfig');
            
            // Reset UI to disconnected state
            ensureDisconnectedState();
        }

        function populateDatasources() {
            const select = document.getElementById('datasource');
            select.innerHTML = '<option value="">Select a data source</option>';
            
            // Filter for InfluxDB and Prometheus datasources
            const supportedDatasources = datasources.filter(ds => 
                ds.type === 'influxdb' || ds.type === 'prometheus'
            );
            
            supportedDatasources.forEach(ds => {
                const option = document.createElement('option');
                option.value = ds.uid;
                option.textContent = `${ds.name} (${ds.type})`;
                option.dataset.type = ds.type;
                option.dataset.id = ds.id;
                select.appendChild(option);
            });
            
            select.disabled = false;
        }

        function enableQueryEditor() {
            document.getElementById('query').disabled = false;
            document.getElementById('executeBtn').disabled = false;
        }

        // Query functions
        function setQueryType(type) {
            currentQueryType = type;
            document.querySelectorAll('.query-type-button').forEach(function(btn) {
                btn.classList.remove('active');
            });
            
            // Find the button that was clicked and make it active
            document.querySelectorAll('.query-type-button').forEach(function(btn) {
                if (btn.textContent.toLowerCase().includes(type.toLowerCase())) {
                    btn.classList.add('active');
                }
            });
            
            // Show/hide PromQL specific options
            const promqlOptions = document.getElementById('promqlOptions');
            if (type === 'promql') {
                promqlOptions.style.display = 'block';
            } else {
                promqlOptions.style.display = 'none';
            }
            
            // Update placeholder text
            const queryTextarea = document.getElementById('query');
            if (type === 'influxql') {
                queryTextarea.placeholder = 'Enter InfluxQL query (e.g., SELECT * FROM measurement WHERE time > now() - 1h)';
            } else {
                queryTextarea.placeholder = 'Enter PromQL query (e.g., up{job="prometheus"})';
            }
        }

        async function executeQuery() {
            const datasourceId = document.getElementById('datasource').value;
            const query = document.getElementById('query').value.trim();
            
            if (!datasourceId) {
                showResults('Please select a data source', 'error');
                return;
            }
            
            if (!query) {
                showResults('Please enter a query', 'error');
                return;
            }
            
            const selectedOption = document.getElementById('datasource').selectedOptions[0];
            const datasourceType = selectedOption.dataset.type;
            const datasourceNumericId = selectedOption.dataset.id;
            
            // Get time range
            const timeFromHours = parseFloat(document.getElementById('timeFrom').value) || 1;
            const timeToHours = parseFloat(document.getElementById('timeTo').value) || 0;
            const now = Date.now();
            const fromTime = now - (timeFromHours * 60 * 60 * 1000);
            const toTime = now - (timeToHours * 60 * 60 * 1000);
            
            // Get advanced options
            const maxDataPoints = parseInt(document.getElementById('maxDataPoints').value) || 1000;
            const intervalMs = parseInt(document.getElementById('intervalMs').value) || 15000;
            const instantQuery = document.getElementById('instantQuery').checked;
            
            showResults('Executing query...', 'loading');
            
            try {
                // Prepare the query request based on datasource type
                let requestBody;
                let urlParams = '';
                
                if (datasourceType === 'prometheus') {
                    // Generate unique request ID
                    const requestId = Math.random().toString(36).substr(2, 9);
                    
                    // Add URL parameters like Grafana does
                    urlParams = `?ds_type=prometheus&requestId=${requestId}`;
                    
                    requestBody = {
                        queries: [{
                            refId: 'A',
                            datasource: { 
                                uid: datasourceId,
                                type: 'prometheus'
                            },
                            expr: query,
                            instant: instantQuery,
                            interval: '',
                            legendFormat: '',
                            editorMode: 'code',
                            exemplar: false,
                            requestId: requestId.substr(0, 3).toUpperCase(),
                            utcOffsetSec: new Date().getTimezoneOffset() * -60,
                            scopes: [],
                            adhocFilters: [],
                            datasourceId: parseInt(datasourceNumericId),
                            intervalMs: intervalMs,
                            maxDataPoints: maxDataPoints
                        }],
                        from: fromTime.toString(),
                        to: toTime.toString()
                    };
                } else if (datasourceType === 'influxdb') {
                    // Generate unique request ID
                    const requestId = Math.random().toString(36).substr(2, 9);
                    
                    // Add URL parameters
                    urlParams = `?ds_type=influxdb&requestId=${requestId}`;
                    
                    requestBody = {
                        queries: [{
                            refId: 'A',
                            datasource: { 
                                uid: datasourceId,
                                type: 'influxdb'
                            },
                            query: query,
                            rawQuery: true,
                            resultFormat: 'time_series',
                            requestId: requestId.substr(0, 3).toUpperCase(),
                            utcOffsetSec: new Date().getTimezoneOffset() * -60,
                            datasourceId: parseInt(datasourceNumericId),
                            intervalMs: intervalMs,
                            maxDataPoints: maxDataPoints
                        }],
                        from: fromTime.toString(),
                        to: toTime.toString()
                    };
                }
                
                console.log('Request body:', JSON.stringify(requestBody, null, 2));
                
                const response = await makeApiRequest(`/api/ds/query${urlParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Query failed: ${response.statusText} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log('Response data:', data);
                currentResults = data; // Store results for pagination
                displayResults(data);
                
                // Save to history
                saveToHistory(query, datasourceId, selectedOption.textContent);
                
            } catch (error) {
                showResults(`Error: ${error.message}`, 'error');
                console.error('Query error:', error);
            }
        }

        function displayResults(data, page = 1, seriesIndex = 0) {
            const resultsDiv = document.getElementById('results');
            
            if (!data.results || !data.results.A) {
                showResults('No data returned', 'error');
                return;
            }
            
            const result = data.results.A;
            
            if (result.error) {
                showResults(`Query error: ${result.error}`, 'error');
                return;
            }
            
            if (!result.frames || result.frames.length === 0) {
                showResults('No data found', 'success');
                return;
            }
            
            // Build HTML for results
            let html = '<div class="status success">Query executed successfully</div>';
            
            // Add view toggle controls
            html += '<div class="view-toggle">';
            html += '<button class="' + (currentViewMode === 'table' ? 'active' : '') + '" onclick="setViewMode(\'table\')">Table View</button>';
            html += '<button class="' + (currentViewMode === 'chart' ? 'active' : '') + '" onclick="setViewMode(\'chart\')">Chart View</button>';
            html += '</div>';
            
            // Check if we have multiple series (typical for GROUP BY queries)
            const hasMultipleSeries = result.frames.length > 1;
            selectedSeries = seriesIndex;
            
            if (hasMultipleSeries) {
                html += '<div class="series-selector">';
                html += '<label for="seriesSelect">Select Group (from GROUP BY clause):</label>';
                html += '<select id="seriesSelect" class="series-dropdown" onchange="selectSeries(this.value)">';
                
                result.frames.forEach(function(frame, frameIndex) {
                    const selected = frameIndex === seriesIndex ? 'selected' : '';
                    let seriesName = 'Group ' + (frameIndex + 1);
                    
                    // Extract meaningful series name from the frame data
                    seriesName = extractSeriesName(frame, frameIndex);
                    
                    html += '<option value="' + frameIndex + '" ' + selected + '>' + seriesName + '</option>';
                });
                
                html += '</select>';
                html += '<div class="series-info">Showing group ' + (seriesIndex + 1) + ' of ' + result.frames.length + ' (each group represents one GROUP BY value)</div>';
                html += '</div>';
                
                // Add summary statistics for all groups
                html += generateGroupSummary(result.frames);
            }
            
            // Display the selected frame (or first frame if no selection)
            const frameToDisplay = result.frames[seriesIndex] || result.frames[0];
            
            if (frameToDisplay && frameToDisplay.schema && frameToDisplay.schema.fields && frameToDisplay.data && frameToDisplay.data.values) {
                if (hasMultipleSeries) {
                    const groupName = extractSeriesName(frameToDisplay, seriesIndex);
                    html += '<h3>Group: ' + groupName + '</h3>';
                } else {
                    html += '<h3>Results</h3>';
                }
                
                // Show metadata if available
                if (frameToDisplay.schema.meta && frameToDisplay.schema.meta.executedQueryString) {
                    html += '<p style="color: #888; margin-bottom: 10px; font-size: 12px;">Executed: ' + frameToDisplay.schema.meta.executedQueryString + '</p>';
                }
                
                // Render based on view mode
                if (currentViewMode === 'chart') {
                    html += renderChartView(frameToDisplay, hasMultipleSeries ? result.frames : [frameToDisplay]);
                } else {
                    html += renderTableView(frameToDisplay, page);
                }
            }
            
            // Show summary of all series if multiple exist
            if (hasMultipleSeries) {
                html += '<details style="margin-top: 20px;"><summary style="cursor: pointer; color: #f46800;">View All Groups Summary</summary>';
                html += '<div style="margin-top: 10px;">';
                result.frames.forEach(function(frame, frameIndex) {
                    const rowCount = frame.data && frame.data.values && frame.data.values[0] ? frame.data.values[0].length : 0;
                    const groupName = extractSeriesName(frame, frameIndex);
                    html += '<p style="color: #b0b0b0; margin: 5px 0;"><strong>' + groupName + '</strong>: ' + rowCount + ' rows</p>';
                });
                html += '</div></details>';
            }
            
            // Also show raw JSON for debugging
            html += '<details style="margin-top: 20px;"><summary style="cursor: pointer; color: #f46800;">View Raw Response</summary>';
            html += `<pre>${JSON.stringify(data, null, 2)}</pre>`;
            html += '</details>';
            
            resultsDiv.innerHTML = html;
            
            // If chart view is active, initialize the chart after DOM update
            if (currentViewMode === 'chart') {
                setTimeout(function() {
                    initializeChart(hasMultipleSeries ? result.frames : [frameToDisplay]);
                }, 50);
            }
        }

        // Set view mode (table or chart)
        function setViewMode(mode) {
            currentViewMode = mode;
            if (currentResults) {
                displayResults(currentResults, currentPage, selectedSeries);
            }
        }

        // Render table view
        function renderTableView(frameToDisplay, page) {
            // Calculate pagination for the selected series
            totalRows = frameToDisplay.data.values[0] ? frameToDisplay.data.values[0].length : 0;
            const startRow = (page - 1) * pageSize;
            const endRow = Math.min(startRow + pageSize, totalRows);
            const totalPages = Math.ceil(totalRows / pageSize);
            currentPage = page;
            
            let html = '<div class="table-wrapper"><table>';
            
            // Headers
            html += '<thead><tr>';
            frameToDisplay.schema.fields.forEach(function(field) {
                let headerText = field.name;
                if (field.config && field.config.displayNameFromDS) {
                    headerText = field.config.displayNameFromDS;
                }
                html += '<th>' + headerText + ' (' + field.type + ')</th>';
            });
            html += '</tr></thead>';
            
            // Data (paginated)
            html += '<tbody>';
            for (let i = startRow; i < endRow; i++) {
                html += '<tr>';
                frameToDisplay.data.values.forEach(function(column, colIndex) {
                    let value = column[i];
                    
                    // Format timestamps
                    if (frameToDisplay.schema.fields[colIndex].type === 'time') {
                        value = new Date(value).toLocaleString();
                    }
                    
                    // Format numbers
                    if (typeof value === 'number' && !Number.isInteger(value)) {
                        value = value.toFixed(3);
                    }
                    
                    html += '<td>' + (value !== null && value !== undefined ? value : 'null') + '</td>';
                });
                html += '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            // Pagination controls
            if (totalRows > 0) {
                html += '<div class="pagination-controls">';
                html += '<div class="pagination-info">Showing ' + (startRow + 1) + '-' + endRow + ' of ' + totalRows + ' rows</div>';
                
                html += '<div class="page-size-selector">';
                html += 'Rows per page: ';
                html += '<select onchange="changePageSize(this.value)">';
                [25, 50, 100, 250, 500].forEach(function(size) {
                    const selected = size === pageSize ? 'selected' : '';
                    html += '<option value="' + size + '" ' + selected + '>' + size + '</option>';
                });
                html += '</select>';
                html += '</div>';
                
                html += '<div class="pagination-buttons">';
                html += '<button onclick="goToPage(1)" ' + (page === 1 ? 'disabled' : '') + '>First</button>';
                html += '<button onclick="goToPage(' + (page - 1) + ')" ' + (page === 1 ? 'disabled' : '') + '>Previous</button>';
                html += '<span style="margin: 0 10px; color: #b0b0b0;">Page ' + page + ' of ' + totalPages + '</span>';
                html += '<button onclick="goToPage(' + (page + 1) + ')" ' + (page === totalPages ? 'disabled' : '') + '>Next</button>';
                html += '<button onclick="goToPage(' + totalPages + ')" ' + (page === totalPages ? 'disabled' : '') + '>Last</button>';
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        // Render chart view
        function renderChartView(frameToDisplay, allFrames) {
            let html = '<div class="chart-controls">';
            html += '<div class="chart-options">';
            html += '<div class="chart-option">';
            html += '<input type="checkbox" id="showAllSeries" onchange="updateChart()" ' + (allFrames.length > 1 ? '' : 'disabled') + '>';
            html += '<label for="showAllSeries">Show All Groups</label>';
            html += '</div>';
            html += '<div class="chart-option">';
            html += '<label>Chart Type:</label>';
            html += '<select id="chartType" onchange="updateChart()">';
            html += '<option value="line">Line</option>';
            html += '<option value="bar">Bar</option>';
            html += '<option value="scatter">Scatter</option>';
            html += '</select>';
            html += '</div>';
            html += '<div class="chart-option">';
            html += '<input type="checkbox" id="smoothLines" onchange="updateChart()" checked>';
            html += '<label for="smoothLines">Smooth Lines</label>';
            html += '</div>';
            html += '</div>';
            html += '</div>';
            
            html += '<div class="chart-container">';
            html += '<div class="chart-wrapper">';
            html += '<canvas id="timeSeriesChart"></canvas>';
            html += '</div>';
            html += '</div>';
            
            return html;
        }

        // Initialize chart
        function initializeChart(frames) {
            const canvas = document.getElementById('timeSeriesChart');
            if (!canvas) return;
            
            // Destroy existing chart if it exists
            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
            
            const ctx = canvas.getContext('2d');
            const showAllSeries = document.getElementById('showAllSeries') && document.getElementById('showAllSeries').checked;
            const chartType = document.getElementById('chartType') ? document.getElementById('chartType').value : 'line';
            const smoothLines = document.getElementById('smoothLines') ? document.getElementById('smoothLines').checked : true;
            
            // Prepare data for chart
            const datasets = [];
            const framesToChart = showAllSeries ? frames : [frames[selectedSeries] || frames[0]];
            
            // Color palette for multiple series
            const colors = [
                '#f46800', '#4ade80', '#60a5fa', '#f87171', '#fbbf24',
                '#a78bfa', '#fb7185', '#34d399', '#fcd34d', '#818cf8'
            ];
            
            // Global arrays to store all time points for consistent labeling
            let allTimePoints = [];
            let timeLabels = [];
            
            framesToChart.forEach(function(frame, frameIndex) {
                if (!frame || !frame.data || !frame.data.values) return;
                
                // Find time and value fields
                const timeFieldIndex = frame.schema.fields.findIndex(function(field) {
                    return field.type === 'time';
                });
                const valueFieldIndex = frame.schema.fields.findIndex(function(field) {
                    return field.type === 'number' && field.name !== 'time';
                });
                
                if (timeFieldIndex === -1 || valueFieldIndex === -1) return;
                
                const timeData = frame.data.values[timeFieldIndex];
                const valueData = frame.data.values[valueFieldIndex];
                
                if (!timeData || !valueData) return;
                
                // Create data points and collect time stamps
                const dataPoints = [];
                const frameTimePoints = [];
                
                for (let i = 0; i < Math.min(timeData.length, valueData.length); i++) {
                    if (timeData[i] !== null && valueData[i] !== null) {
                        const timestamp = new Date(timeData[i]);
                        if (!isNaN(timestamp.getTime())) {
                            dataPoints.push(valueData[i]);
                            frameTimePoints.push(timestamp);
                        }
                    }
                }
                
                // Sort data by timestamp
                const sortedData = dataPoints.map(function(value, index) {
                    return { time: frameTimePoints[index], value: value };
                }).sort(function(a, b) {
                    return a.time.getTime() - b.time.getTime();
                });
                
                // Extract sorted values and times
                const sortedValues = sortedData.map(function(item) { return item.value; });
                const sortedTimes = sortedData.map(function(item) { return item.time; });
                
                // Collect all unique time points for consistent x-axis
                sortedTimes.forEach(function(time) {
                    const timeStr = time.toISOString();
                    if (allTimePoints.indexOf(timeStr) === -1) {
                        allTimePoints.push(timeStr);
                    }
                });
                
                const color = colors[frameIndex % colors.length];
                const seriesName = extractSeriesName(frame, frameIndex);
                
                datasets.push({
                    label: seriesName,
                    data: sortedValues,
                    borderColor: color,
                    backgroundColor: color + '20',
                    pointBackgroundColor: color,
                    pointBorderColor: color,
                    pointRadius: chartType === 'scatter' ? 4 : 2,
                    pointHoverRadius: 6,
                    tension: smoothLines ? 0.4 : 0,
                    fill: false,
                    borderWidth: 2,
                    timeData: sortedTimes // Store time data for tooltips
                });
            });
            
            // Sort all time points and create labels
            allTimePoints.sort();
            timeLabels = allTimePoints.map(function(timeStr) {
                const date = new Date(timeStr);
                // Format time labels based on time range
                const now = new Date();
                const diffHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);
                
                if (diffHours < 24) {
                    // Less than 24 hours ago - show time
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                } else if (diffHours < 24 * 7) {
                    // Less than a week ago - show day and time
                    return date.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' +
                           date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                } else {
                    // Older - show date
                    return date.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
                }
            });
            
            // For datasets with different time ranges, pad with null values
            datasets.forEach(function(dataset) {
                const paddedData = [];
                const datasetTimes = dataset.timeData.map(function(time) { return time.toISOString(); });
                
                allTimePoints.forEach(function(timePoint) {
                    const index = datasetTimes.indexOf(timePoint);
                    paddedData.push(index >= 0 ? dataset.data[index] : null);
                });
                
                dataset.data = paddedData;
                delete dataset.timeData; // Clean up temporary data
            });
            
            // Chart configuration using category scale with time labels
            const config = {
                type: chartType,
                data: {
                    labels: timeLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: showAllSeries || datasets.length > 1,
                            labels: {
                                color: '#e0e0e0',
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: '#1a1a1a',
                            titleColor: '#f46800',
                            bodyColor: '#e0e0e0',
                            borderColor: '#333',
                            borderWidth: 1,
                            callbacks: {
                                title: function(context) {
                                    // Show full timestamp in tooltip
                                    const timeStr = allTimePoints[context[0].dataIndex];
                                    return new Date(timeStr).toLocaleString();
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'category',
                            grid: {
                                color: '#333'
                            },
                            ticks: {
                                color: '#b0b0b0',
                                maxRotation: 45,
                                minRotation: 0
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                color: '#b0b0b0'
                            }
                        },
                        y: {
                            grid: {
                                color: '#333'
                            },
                            ticks: {
                                color: '#b0b0b0'
                            },
                            title: {
                                display: true,
                                text: 'Value',
                                color: '#b0b0b0'
                            }
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    spanGaps: true // Connect points even with null values in between
                }
            };
            
            try {
                // Create chart
                chartInstance = new Chart(ctx, config);
                console.log('Chart created successfully with ' + datasets.length + ' datasets');
            } catch (error) {
                console.error('Chart creation error:', error);
                // Show error message in chart container
                document.querySelector('.chart-wrapper').innerHTML = 
                    '<div style="padding: 20px; text-align: center; color: #f87171;">' +
                    'Chart Error: ' + error.message + '<br>' +
                    'Unable to display chart visualization.' +
                    '</div>';
            }
        }

        // Update chart when controls change
        function updateChart() {
            if (currentResults && currentViewMode === 'chart') {
                const result = currentResults.results.A;
                initializeChart(result.frames);
            }
        }

        // Extract meaningful series name from frame data
        function extractSeriesName(frame, frameIndex) {
            let seriesName = 'Group ' + (frameIndex + 1);
            
            try {
                // Method 1: Try to extract from frame name or display name
                if (frame.name) {
                    return frame.name;
                }
                
                // Method 2: Look for tag/label fields in the schema and extract their first values
                if (frame.schema && frame.schema.fields && frame.data && frame.data.values) {
                    const tagFields = frame.schema.fields.filter(function(field) {
                        return field.type === 'string' && 
                               field.name !== 'time' && 
                               !field.name.startsWith('_');
                    });
                    
                    if (tagFields.length > 0 && frame.data.values.length > 0) {
                        const tagValues = [];
                        tagFields.forEach(function(field) {
                            const fieldIndex = frame.schema.fields.indexOf(field);
                            if (fieldIndex >= 0 && frame.data.values[fieldIndex] && frame.data.values[fieldIndex].length > 0) {
                                const value = frame.data.values[fieldIndex][0];
                                if (value !== null && value !== undefined && value !== '') {
                                    tagValues.push(field.name + '=' + value);
                                }
                            }
                        });
                        
                        if (tagValues.length > 0) {
                            seriesName = tagValues.slice(0, 2).join(', ');
                        }
                    }
                }
                
                // Method 3: Try to extract from field labels (Prometheus style)
                if (seriesName === 'Group ' + (frameIndex + 1) && frame.schema && frame.schema.fields) {
                    const labelField = frame.schema.fields.find(function(field) {
                        return field.labels && Object.keys(field.labels).length > 0;
                    });
                    if (labelField && labelField.labels) {
                        const excludeLabels = ['__name__', 'job', 'instance'];
                        const meaningfulLabels = Object.entries(labelField.labels)
                            .filter(function(entry) {
                                const key = entry[0];
                                const value = entry[1];
                                return !excludeLabels.includes(key) && value;
                            })
                            .map(function(entry) {
                                const key = entry[0];
                                const value = entry[1];
                                return key + '="' + value + '"';
                            })
                            .slice(0, 2);
                        
                        if (meaningfulLabels.length > 0) {
                            seriesName = meaningfulLabels.join(', ');
                        }
                    }
                }
                
                // Method 4: Try to use display name from config
                if (seriesName === 'Group ' + (frameIndex + 1) && frame.schema && frame.schema.fields) {
                    const displayField = frame.schema.fields.find(function(field) {
                        return field.config && field.config.displayNameFromDS;
                    });
                    if (displayField && displayField.config.displayNameFromDS) {
                        seriesName = displayField.config.displayNameFromDS;
                    }
                }
                
            } catch (error) {
                console.warn('Error extracting series name:', error);
            }
            
            return seriesName;
        }

        // Generate summary statistics for all groups
        function generateGroupSummary(frames) {
            if (!frames || frames.length <= 1) return '';
            
            let html = '<div class="series-stats">';
            html += '<h4>Group Summary Statistics</h4>';
            html += '<div class="stats-grid">';
            
            // Total groups
            html += '<div class="stat-item">';
            html += '<div class="stat-label">Total Groups</div>';
            html += `<div class="stat-value">${frames.length}</div>`;
            html += '</div>';
            
            // Total rows across all groups
            const totalRows = frames.reduce((sum, frame) => {
                const rows = frame.data && frame.data.values && frame.data.values[0] ? frame.data.values[0].length : 0;
                return sum + rows;
            }, 0);
            
            html += '<div class="stat-item">';
            html += '<div class="stat-label">Total Rows</div>';
            html += `<div class="stat-value">${totalRows.toLocaleString()}</div>`;
            html += '</div>';
            
            // Average rows per group
            const avgRows = frames.length > 0 ? Math.round(totalRows / frames.length) : 0;
            html += '<div class="stat-item">';
            html += '<div class="stat-label">Avg Rows/Group</div>';
            html += `<div class="stat-value">${avgRows}</div>`;
            html += '</div>';
            
            // Largest group
            const maxRows = Math.max(...frames.map(frame => 
                frame.data && frame.data.values && frame.data.values[0] ? frame.data.values[0].length : 0
            ));
            html += '<div class="stat-item">';
            html += '<div class="stat-label">Largest Group</div>';
            html += `<div class="stat-value">${maxRows}</div>`;
            html += '</div>';
            
            // Smallest group
            const minRows = Math.min(...frames.map(frame => 
                frame.data && frame.data.values && frame.data.values[0] ? frame.data.values[0].length : 0
            ));
            html += '<div class="stat-item">';
            html += '<div class="stat-label">Smallest Group</div>';
            html += `<div class="stat-value">${minRows}</div>`;
            html += '</div>';
            
            html += '</div></div>';
            return html;
        }

        // Series selection function
        function selectSeries(seriesIndex) {
            const index = parseInt(seriesIndex);
            if (currentResults && index >= 0) {
                currentPage = 1; // Reset to first page when switching series
                displayResults(currentResults, currentPage, index);
            }
        }

        // Pagination functions
        function goToPage(page) {
            if (currentResults && page >= 1 && page <= Math.ceil(totalRows / pageSize)) {
                displayResults(currentResults, page, selectedSeries);
            }
        }

        function changePageSize(newSize) {
            pageSize = parseInt(newSize);
            currentPage = 1; // Reset to first page
            if (currentResults) {
                displayResults(currentResults, currentPage, selectedSeries);
            }
        }

        function showResults(message, type) {
            const resultsDiv = document.getElementById('results');
            currentResults = null; // Clear current results
            selectedSeries = 0; // Reset series selection
            if (type === 'loading') {
                resultsDiv.innerHTML = `<div class="loading">${message}</div>`;
            } else {
                resultsDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            }
        }

        function clearQuery() {
            document.getElementById('query').value = '';
        }

        // History functions
        function saveToHistory(query, datasourceId, datasourceName) {
            const history = getHistory();
            const historyItem = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                query: query,
                datasourceId: datasourceId,
                datasourceName: datasourceName,
                queryType: currentQueryType
            };
            
            history.unshift(historyItem);
            
            // Keep only last 50 queries
            if (history.length > 50) {
                history.pop();
            }
            
            localStorage.setItem('queryHistory', JSON.stringify(history));
            loadHistory();
        }

        function getHistory() {
            const history = localStorage.getItem('queryHistory');
            return history ? JSON.parse(history) : [];
        }

        function loadHistory() {
            const history = getHistory();
            const historyList = document.getElementById('historyList');
            
            if (history.length === 0) {
                historyList.innerHTML = '<p style="color: #888; text-align: center;">No queries in history</p>';
                return;
            }
            
            historyList.innerHTML = history.map(function(item) {
                return '<div class="history-item" onclick="loadHistoryItem(' + item.id + ')">' +
                    '<div class="history-timestamp">' + new Date(item.timestamp).toLocaleString() + '</div>' +
                    '<div class="history-query">' + escapeHtml(item.query) + '</div>' +
                    '<div class="history-datasource">' + item.datasourceName + ' (' + (item.queryType || 'unknown') + ')</div>' +
                    '</div>';
            }).join('');
        }

        function loadHistoryItem(id) {
            const history = getHistory();
            const item = history.find(h => h.id === id);
            
            if (item) {
                document.getElementById('query').value = item.query;
                
                // Set query type
                if (item.queryType) {
                    setQueryType(item.queryType);
                    // Update the UI button
                    document.querySelectorAll('.query-type-button').forEach(function(btn) {
                        btn.classList.remove('active');
                    });
                    const targetButton = document.querySelector('[onclick*="' + item.queryType + '"]');
                    if (targetButton) {
                        targetButton.classList.add('active');
                    }
                }
                
                // Try to select the datasource
                const datasourceSelect = document.getElementById('datasource');
                if (datasourceSelect.querySelector(`option[value="${item.datasourceId}"]`)) {
                    datasourceSelect.value = item.datasourceId;
                }
            }
        }

        function clearHistory() {
            if (confirm('Are you sure you want to clear all query history?')) {
                localStorage.removeItem('queryHistory');
                loadHistory();
            }
        }

        // Utility functions
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            if (type === 'loading') {
                element.innerHTML = `<div class="loading">${message}</div>`;
            } else {
                element.innerHTML = `<div class="status ${type}">${message}</div>`;
            }
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
    </script>
</body>
</html>